From 2ba62cd5c0d267ede8f935b2473bb317f93a25d3 Mon Sep 17 00:00:00 2001
From: "Alan T. DeKok" <aland@freeradius.org>
Date: Thu, 3 Nov 2016 09:50:56 -0400
Subject: [PATCH] Rename lt_* to fr_*.  Fixes #1277

Which fixes linker issues in libraries which link to libtool,
and then sometimes get the wrong function.

Changed via:

perl -p -i -e 's/lt_dlhandle/fr_dlhandle/g;s/lt_dlopenext/fr_dlopenext/g;s/lt_dlsym/fr_dlsym/g;s/lt_dlclose/fr_dlclose/g;s/lt_dlerror/fr_dlerror/g;' $(find . -name "*.[ch]" -print)
---
 src/include/modpriv.h             | 12 ++++++------
 src/main/listen.c                 | 10 +++++-----
 src/main/modules.c                | 10 +++++-----
 src/modules/rlm_cache/rlm_cache.c |  2 +-
 src/modules/rlm_eap/eap.c         |  2 +-
 src/modules/rlm_eap/rlm_eap.h     |  2 +-
 src/modules/rlm_sql/rlm_sql.c     |  2 +-
 7 files changed, 20 insertions(+), 20 deletions(-)

diff --git a/src/include/modpriv.h b/src/include/modpriv.h
index d5e2c2392..f69b47c35 100644
--- a/src/include/modpriv.h
+++ b/src/include/modpriv.h
@@ -18,12 +18,12 @@
 extern "C" {
 #endif
 
-typedef void *lt_dlhandle;
+typedef void *fr_dlhandle;
 
-lt_dlhandle lt_dlopenext(char const *name);
-void *lt_dlsym(lt_dlhandle handle, char const *symbol);
-int lt_dlclose(lt_dlhandle handle);
-char const *lt_dlerror(void);
+fr_dlhandle fr_dlopenext(char const *name);
+void *fr_dlsym(fr_dlhandle handle, char const *symbol);
+int fr_dlclose(fr_dlhandle handle);
+char const *fr_dlerror(void);
 
 /*
  *	Keep track of which modules we've loaded.
@@ -31,7 +31,7 @@ char const *lt_dlerror(void);
 typedef struct module_entry_t {
 	char			name[MAX_STRING_LEN];
 	module_t const		*module;
-	lt_dlhandle		handle;
+	fr_dlhandle		handle;
 } module_entry_t;
 
 typedef struct fr_module_hup_t fr_module_hup_t;
diff --git a/src/main/listen.c b/src/main/listen.c
index 65e5c8bf1..5bf9c7b8a 100644
--- a/src/main/listen.c
+++ b/src/main/listen.c
@@ -2936,7 +2936,7 @@ static const FR_NAME_NUMBER listen_compare[] = {
 	{ NULL, 0 },
 };
 
-static int _free_proto_handle(lt_dlhandle *handle)
+static int _free_proto_handle(fr_dlhandle *handle)
 {
 	dlclose(*handle);
 	return 0;
@@ -2949,7 +2949,7 @@ static rad_listen_t *listen_parse(CONF_SECTION *cs, char const *server)
 	rad_listen_t	*this;
 	CONF_PAIR	*cp;
 	char const	*value;
-	lt_dlhandle	handle;
+	fr_dlhandle	handle;
 	CONF_SECTION	*server_cs;
 	char		buffer[32];
 
@@ -2968,10 +2968,10 @@ static rad_listen_t *listen_parse(CONF_SECTION *cs, char const *server)
 	}
 
 	snprintf(buffer, sizeof(buffer), "proto_%s", value);
-	handle = lt_dlopenext(buffer);
+	handle = fr_dlopenext(buffer);
 	if (handle) {
 		fr_protocol_t	*proto;
-		lt_dlhandle	*marker;
+		fr_dlhandle	*marker;
 
 		proto = dlsym(handle, buffer);
 		if (!proto) {
@@ -2990,7 +2990,7 @@ static rad_listen_t *listen_parse(CONF_SECTION *cs, char const *server)
 		/*
 		 *	Ensure handle gets closed if config section gets freed
 		 */
-		marker = talloc(cs, lt_dlhandle);
+		marker = talloc(cs, fr_dlhandle);
 		*marker = handle;
 		talloc_set_destructor(marker, _free_proto_handle);
 
diff --git a/src/main/modules.c b/src/main/modules.c
index 885cbee21..91218dd5f 100644
--- a/src/main/modules.c
+++ b/src/main/modules.c
@@ -155,7 +155,7 @@ static int check_module_magic(CONF_SECTION *cs, module_t const *module)
 	return 0;
 }
 
-lt_dlhandle lt_dlopenext(char const *name)
+fr_dlhandle fr_dlopenext(char const *name)
 {
 	int		flags = RTLD_NOW;
 	void		*handle;
@@ -273,19 +273,19 @@ lt_dlhandle lt_dlopenext(char const *name)
 	return handle;
 }
 
-void *lt_dlsym(lt_dlhandle handle, char const *symbol)
+void *fr_dlsym(fr_dlhandle handle, char const *symbol)
 {
 	return dlsym(handle, symbol);
 }
 
-int lt_dlclose(lt_dlhandle handle)
+int fr_dlclose(fr_dlhandle handle)
 {
 	if (!handle) return 0;
 
 	return dlclose(handle);
 }
 
-char const *lt_dlerror(void)
+char const *fr_dlerror(void)
 {
 	return dlerror();
 }
@@ -516,7 +516,7 @@ static module_entry_t *module_dlopen(CONF_SECTION *cs, char const *module_name)
 	/*
 	 *	Keep the handle around so we can dlclose() it.
 	 */
-	handle = lt_dlopenext(module_name);
+	handle = fr_dlopenext(module_name);
 	if (!handle) {
 		cf_log_err_cs(cs, "Failed to link to module '%s': %s", module_name, fr_strerror());
 		return NULL;
diff --git a/src/modules/rlm_cache/rlm_cache.c b/src/modules/rlm_cache/rlm_cache.c
index 76ba6a442..248de8bf9 100644
--- a/src/modules/rlm_cache/rlm_cache.c
+++ b/src/modules/rlm_cache/rlm_cache.c
@@ -712,7 +712,7 @@ static int mod_instantiate(CONF_SECTION *conf, void *instance)
 	/*
 	 *	Load the appropriate driver for our database
 	 */
-	inst->handle = lt_dlopenext(inst->driver_name);
+	inst->handle = fr_dlopenext(inst->driver_name);
 	if (!inst->handle) {
 		cf_log_err_cs(conf, "Could not link driver %s: %s", inst->driver_name, dlerror());
 		cf_log_err_cs(conf, "Make sure it (and all its dependent libraries!) are in the search path"
diff --git a/src/modules/rlm_eap/eap.c b/src/modules/rlm_eap/eap.c
index d9660ed42..b03654fed 100644
--- a/src/modules/rlm_eap/eap.c
+++ b/src/modules/rlm_eap/eap.c
@@ -125,7 +125,7 @@ int eap_module_instantiate(rlm_eap_t *inst, eap_module_t **m_inst, eap_type_t nu
 	/*
 	 *	Link the loaded EAP-Type
 	 */
-	method->handle = lt_dlopenext(mod_name);
+	method->handle = fr_dlopenext(mod_name);
 	if (!method->handle) {
 		ERROR("rlm_eap (%s): Failed to link %s: %s", inst->xlat_name, mod_name, fr_strerror());
 
diff --git a/src/modules/rlm_eap/rlm_eap.h b/src/modules/rlm_eap/rlm_eap.h
index 0edf462bd..384f7f78d 100644
--- a/src/modules/rlm_eap/rlm_eap.h
+++ b/src/modules/rlm_eap/rlm_eap.h
@@ -36,7 +36,7 @@ RCSIDH(rlm_eap_h, "$Id$")
 typedef struct eap_module {
 	char const		*name;
 	rlm_eap_module_t	*type;
-	lt_dlhandle		handle;
+	fr_dlhandle		handle;
 	CONF_SECTION		*cs;
 	void			*instance;
 } eap_module_t;
diff --git a/src/modules/rlm_sql/rlm_sql.c b/src/modules/rlm_sql/rlm_sql.c
index fafcd6353..e005f79a2 100644
--- a/src/modules/rlm_sql/rlm_sql.c
+++ b/src/modules/rlm_sql/rlm_sql.c
@@ -843,7 +843,7 @@ static int mod_bootstrap(CONF_SECTION *conf, void *instance)
 	 *
 	 *	We need this to check if the sql_fields callback is provided.
 	 */
-	inst->handle = lt_dlopenext(inst->config->sql_driver_name);
+	inst->handle = fr_dlopenext(inst->config->sql_driver_name);
 	if (!inst->handle) {
 		ERROR("Could not link driver %s: %s", inst->config->sql_driver_name, fr_strerror());
 		ERROR("Make sure it (and all its dependent libraries!) are in the search path of your system's ld");
-- 
2.11.0

